// src/types/document.ts - CREATED: 2025-07-07 - Document type definitions based on canonical JSON structure

import { z } from "zod";

// =============================================================================
// Core Document Interfaces
// =============================================================================

export interface CanonicalDocument {
  metadata: DocumentMetadata;
  content: CanonicalBlock[];
  version: string;
  createdAt: string;
  updatedAt: string;
}

export interface DocumentMetadata {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string[];
  documentType: "report" | "article" | "form" | "contract" | "other";
  language: string;
  confidenceScore: number;
}

// =============================================================================
// Block Types
// =============================================================================

export type CanonicalBlock =
  | HeadingBlock
  | ParagraphBlock
  | ListBlock
  | TableBlock
  | ImageBlock
  | CodeBlock
  | BlockquoteBlock
  | MultipleChoiceBlock
  | DividerBlock;

export interface BaseBlock {
  id: string;
  type: string;
  metadata?: {
    confidence?: number;
    sourceContext?: string;
  };
}

export interface HeadingBlock extends BaseBlock {
  type: "heading";
  level: 1 | 2 | 3;
  content: InlineContent[];
}

export interface ParagraphBlock extends BaseBlock {
  type: "paragraph";
  content: InlineContent[];
}

export interface ListBlock extends BaseBlock {
  type: "list";
  listType: "bulleted" | "numbered";
  items: ListItem[];
}

export interface ListItem {
  id: string;
  content: InlineContent[];
  items?: ListItem[]; // For nested lists
}

export interface TableBlock extends BaseBlock {
  type: "table";
  headers: TableRow;
  rows: TableRow[];
  caption?: string;
}

export interface TableRow {
  id: string;
  cells: TableCell[];
}

export interface TableCell {
  id: string;
  content: InlineContent[];
  colspan?: number;
  rowspan?: number;
  isHeader?: boolean;
}

export interface ImageBlock extends BaseBlock {
  type: "image";
  src: string;
  alt?: string;
  caption?: string;
  width?: number;
  height?: number;
}

export interface CodeBlock extends BaseBlock {
  type: "codeBlock";
  content: string;
  language?: string;
}

export interface BlockquoteBlock extends BaseBlock {
  type: "blockquote";
  content: CanonicalBlock[];
  citation?: string;
}

export interface MultipleChoiceBlock extends BaseBlock {
  type: "multipleChoice";
  question: InlineContent[];
  options: MultipleChoiceOption[];
  correctAnswer?: number;
}

export interface MultipleChoiceOption {
  id: string;
  content: InlineContent[];
  isCorrect?: boolean;
}

export interface DividerBlock extends BaseBlock {
  type: "divider";
  style?: "solid" | "dashed" | "dotted";
}

// =============================================================================
// Inline Content Types
// =============================================================================

export type InlineContent =
  | TextContent
  | FormattedTextContent
  | LinkContent
  | BreakContent;

export interface TextContent {
  type: "text";
  text: string;
}

export interface FormattedTextContent {
  type: "text";
  text: string;
  formatting: TextFormatting;
}

export interface TextFormatting {
  bold?: boolean;
  italic?: boolean;
  underline?: boolean;
  strikethrough?: boolean;
  code?: boolean;
  superscript?: boolean;
  subscript?: boolean;
}

export interface LinkContent {
  type: "link";
  text: string;
  url: string;
  title?: string;
}

export interface BreakContent {
  type: "break";
  breakType: "soft" | "hard";
}

// =============================================================================
// Zod Schema Validation
// =============================================================================

const TextFormattingSchema = z.object({
  bold: z.boolean().optional(),
  italic: z.boolean().optional(),
  underline: z.boolean().optional(),
  strikethrough: z.boolean().optional(),
  code: z.boolean().optional(),
  superscript: z.boolean().optional(),
  subscript: z.boolean().optional(),
});

const InlineContentSchema: z.ZodType<InlineContent> = z.discriminatedUnion("type", [
  z.object({
    type: z.literal("text"),
    text: z.string(),
    formatting: TextFormattingSchema.optional(),
  }),
  z.object({
    type: z.literal("link"),
    text: z.string(),
    url: z.string().url(),
    title: z.string().optional(),
  }),
  z.object({
    type: z.literal("break"),
    breakType: z.enum(["soft", "hard"]),
  }),
]);

const DocumentMetadataSchema = z.object({
  title: z.string().optional(),
  author: z.string().optional(),
  subject: z.string().optional(),
  keywords: z.array(z.string()).optional(),
  documentType: z.enum(["report", "article", "form", "contract", "other"]),
  language: z.string(),
  confidenceScore: z.number().min(0).max(1),
});

const BaseBlockSchema = z.object({
  id: z.string(),
  type: z.string(),
  metadata: z.object({
    confidence: z.number().optional(),
    sourceContext: z.string().optional(),
  }).optional(),
});

const CanonicalDocumentSchema = z.object({
  metadata: DocumentMetadataSchema,
  content: z.array(z.any()), // Will be validated by specific block schemas
  version: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

// =============================================================================
// Validation Functions
// =============================================================================

export const validateCanonicalDocument = (doc: unknown): CanonicalDocument => {
  return CanonicalDocumentSchema.parse(doc) as CanonicalDocument;
};

export const validateDocumentMetadata = (metadata: unknown): DocumentMetadata => {
  return DocumentMetadataSchema.parse(metadata);
};

export const validateInlineContent = (content: unknown): InlineContent => {
  return InlineContentSchema.parse(content);
};

// =============================================================================
// Error Classes
// =============================================================================

export class DocumentProcessingError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = "DocumentProcessingError";
  }
}

export class DocumentValidationError extends Error {
  constructor(message: string, public details?: any) {
    super(message);
    this.name = "DocumentValidationError";
    this.details = details;
  }
}

// =============================================================================
// Utility Functions
// =============================================================================

export const generateBlockId = (): string => {
  return `block_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

export const createEmptyCanonicalDocument = (): CanonicalDocument => {
  return {
    metadata: {
      documentType: "other",
      language: "en",
      confidenceScore: 0.5,
    },
    content: [],
    version: "1.0",
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };
};

export const isTextContent = (content: InlineContent): content is TextContent | FormattedTextContent => {
  return content.type === "text";
};

export const isLinkContent = (content: InlineContent): content is LinkContent => {
  return content.type === "link";
};

export const isBreakContent = (content: InlineContent): content is BreakContent => {
  return content.type === "break";
};







// src/types/template.ts - CREATED: 2025-07-07 - Template type definitions for PDF generation

import { z } from "zod";

// =============================================================================
// PDF Template Types (Based on pdfme)
// =============================================================================

export interface PdfTemplate {
  id: string;
  name: string;
  description?: string;
  template_json: Template;
  user_id?: string;
  created_at?: string;
  updated_at?: string;
}

export interface Template {
  basePdf?: string | Uint8Array;
  schemas: Schema[][];
  sampledata?: Record<string, any>[];
  columns?: string[];
}

export interface Schema {
  name: string;
  type: string;
  position: Position;
  width: number;
  height: number;
  rotate?: number;
  opacity?: number;
  readOnly?: boolean;
  required?: boolean;
  
  // Text-specific properties
  fontSize?: number;
  fontName?: string;
  fontColor?: string;
  backgroundColor?: string;
  alignment?: "left" | "center" | "right";
  verticalAlignment?: "top" | "middle" | "bottom";
  lineHeight?: number;
  characterSpacing?: number;
  
  // Table-specific properties
  borderWidth?: number;
  borderColor?: string;
  padding?: number;
  
  // Image-specific properties
  fit?: "contain" | "cover" | "fill";
  
  // Additional properties
  [key: string]: any;
}

export interface Position {
  x: number;
  y: number;
}

// =============================================================================
// pdfme Options and Configuration
// =============================================================================

export interface PdfmeOptions {
  startY?: number;
  pageWidth?: number;
  pageHeight?: number;
  margin?: number;
  font?: {
    [key: string]: string;
  };
}

export interface PdfGenerationInput {
  [fieldName: string]: string | number | boolean | any[];
}

export interface PdfGenerationOptions {
  template: Template;
  inputs: PdfGenerationInput[];
  options?: PdfmeOptions;
}

// =============================================================================
// Supabase Template Database Schema
// =============================================================================

export interface TemplateRow {
  id: string;
  name: string;
  description?: string;
  template_json: Template;
  user_id: string;
  created_at: string;
  updated_at: string;
  is_public: boolean;
  category?: string;
  tags?: string[];
}

// =============================================================================
// Template Validation Schemas
// =============================================================================

const PositionSchema = z.object({
  x: z.number(),
  y: z.number(),
});

const SchemaSchema = z.object({
  name: z.string(),
  type: z.string(),
  position: PositionSchema,
  width: z.number(),
  height: z.number(),
  rotate: z.number().optional(),
  opacity: z.number().min(0).max(1).optional(),
  readOnly: z.boolean().optional(),
  required: z.boolean().optional(),
  fontSize: z.number().optional(),
  fontName: z.string().optional(),
  fontColor: z.string().optional(),
  backgroundColor: z.string().optional(),
  alignment: z.enum(["left", "center", "right"]).optional(),
  verticalAlignment: z.enum(["top", "middle", "bottom"]).optional(),
  lineHeight: z.number().optional(),
  characterSpacing: z.number().optional(),
  borderWidth: z.number().optional(),
  borderColor: z.string().optional(),
  padding: z.number().optional(),
  fit: z.enum(["contain", "cover", "fill"]).optional(),
});

const TemplateSchema = z.object({
  basePdf: z.union([z.string(), z.instanceof(Uint8Array)]).optional(),
  schemas: z.array(z.array(SchemaSchema)),
  sampledata: z.array(z.record(z.any())).optional(),
  columns: z.array(z.string()).optional(),
});

const PdfTemplateSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  template_json: TemplateSchema,
  user_id: z.string().optional(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
});

const TemplateRowSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  template_json: TemplateSchema,
  user_id: z.string(),
  created_at: z.string(),
  updated_at: z.string(),
  is_public: z.boolean(),
  category: z.string().optional(),
  tags: z.array(z.string()).optional(),
});

// =============================================================================
// Validation Functions
// =============================================================================

export const validateTemplate = (template: unknown): Template => {
  return TemplateSchema.parse(template);
};

export const validatePdfTemplate = (template: unknown): PdfTemplate => {
  return PdfTemplateSchema.parse(template);
};

export const validateTemplateRow = (row: unknown): TemplateRow => {
  return TemplateRowSchema.parse(row);
};

export const validateSchema = (schema: unknown): Schema => {
  return SchemaSchema.parse(schema);
};

// =============================================================================
// Template Utility Functions
// =============================================================================

export const createEmptyTemplate = (): Template => {
  return {
    schemas: [[]],
    sampledata: [{}],
  };
};

export const createBasicTextTemplate = (): Template => {
  return {
    schemas: [
      [
        {
          name: "title",
          type: "text",
          position: { x: 20, y: 20 },
          width: 170,
          height: 15,
          fontSize: 18,
          fontName: "NotoSansCJK-Regular",
          alignment: "center",
        },
        {
          name: "content",
          type: "text",
          position: { x: 20, y: 50 },
          width: 170,
          height: 200,
          fontSize: 12,
          fontName: "NotoSansCJK-Regular",
          lineHeight: 1.5,
        },
      ],
    ],
    sampledata: [
      {
        title: "Sample Document",
        content: "This is sample content for the document.",
      },
    ],
  };
};

export const generateSchemaId = (): string => {
  return `schema_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

export const getTemplateFieldNames = (template: Template): string[] => {
  const fieldNames = new Set<string>();
  
  template.schemas.forEach(page => {
    page.forEach(schema => {
      fieldNames.add(schema.name);
    });
  });
  
  return Array.from(fieldNames);
};

export const validateTemplateInputs = (
  template: Template, 
  inputs: PdfGenerationInput[]
): boolean => {
  const fieldNames = getTemplateFieldNames(template);
  
  return inputs.every(input => {
    return fieldNames.every(fieldName => {
      return fieldName in input;
    });
  });
};

// =============================================================================
// Error Classes
// =============================================================================

export class TemplateValidationError extends Error {
  constructor(message: string, public details?: any) {
    super(message);
    this.name = "TemplateValidationError";
    this.details = details;
  }
}

export class PdfGenerationError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = "PdfGenerationError";
  }
}

// =============================================================================
// Constants
// =============================================================================

export const BLANK_PDF = "data:application/pdf;base64,JVBERi0xLjQKMSAwIG9iago8PAovVHlwZSAvQ2F0YWxvZwovUGFnZXMgMiAwIFIKPj4KZW5kb2JqCjIgMCBvYmoKPDwKL1R5cGUgL1BhZ2VzCi9LaWRzIFszIDAgUl0KL0NvdW50IDEKL01lZGlhQm94IFswIDAgNTk1IDg0Ml0KPj4KZW5kb2JqCjMgMCBvYmoKPDwKL1R5cGUgL1BhZ2UKL1BhcmVudCAyIDAgUgovUmVzb3VyY2VzIDw8Cj4+Cj4+CmVuZG9iagp4cmVmCjAgNAowMDAwMDAwMDAwIDY1NTM1IGYKMDAwMDAwMDAwOSAwMDAwMCBuCjAwMDAwMDAwNTggMDAwMDAgbgowMDAwMDAwMTI1IDAwMDAwIG4KdHJhaWxlcgo8PAovU2l6ZSA0Ci9Sb290IDEgMCBSCj4+CnN0YXJ0eHJlZgoxNzgKJSVFT0Y=";

export const DEFAULT_PAGE_SIZE = {
  A4: { width: 210, height: 297 },
  LETTER: { width: 216, height: 279 },
  A3: { width: 297, height: 420 },
};

export const DEFAULT_FONTS = {
  "NotoSansCJK-Regular": "NotoSansCJK-Regular",
  "Helvetica": "Helvetica",
  "Times-Roman": "Times-Roman",
  "Courier": "Courier",
};












// src/lib/services/gemini.ts - CREATED: 2025-07-07 - Gemini AI integration with new SDK

import { GoogleGenAI } from '@google/genai';
import { CanonicalDocument, DocumentProcessingError, validateCanonicalDocument } from '@/types/document';

// =============================================================================
// Gemini Configuration
// =============================================================================

interface GeminiConfig {
  apiKey: string;
  model: string;
  timeout: number;
  maxRetries: number;
  temperature: number;
  topP: number;
  topK: number;
  maxOutputTokens: number;
}

const DEFAULT_CONFIG: Omit<GeminiConfig, 'apiKey'> = {
  model: 'gemini-2.0-flash',
  timeout: 30000,
  maxRetries: 3,
  temperature: 0.1,
  topP: 0.9,
  topK: 25,
  maxOutputTokens: 8192,
};

// =============================================================================
// Response Schema for Structured Output
// =============================================================================

const CANONICAL_DOCUMENT_SCHEMA = {
  type: "object",
  properties: {
    metadata: {
      type: "object",
      properties: {
        title: { type: "string", nullable: true },
        author: { type: "string", nullable: true },
        subject: { type: "string", nullable: true },
        keywords: {
          type: "array",
          items: { type: "string" },
          nullable: true,
        },
        documentType: {
          type: "string",
          enum: ["report", "article", "form", "contract", "other"],
        },
        language: { type: "string" },
        confidenceScore: { type: "number", minimum: 0, maximum: 1 },
      },
      required: ["documentType", "language", "confidenceScore"],
    },
    content: {
      type: "array",
      items: {
        type: "object",
        properties: {
          id: { type: "string" },
          type: {
            type: "string",
            enum: [
              "heading",
              "paragraph",
              "list",
              "table",
              "image",
              "codeBlock",
              "blockquote",
              "multipleChoice",
              "divider",
            ],
          },
        },
        required: ["id", "type"],
      },
    },
    version: { type: "string" },
    createdAt: { type: "string" },
    updatedAt: { type: "string" },
  },
  required: ["metadata", "content", "version", "createdAt", "updatedAt"],
};

// =============================================================================
// Gemini Document Processor Class
// =============================================================================

export class GeminiDocumentProcessor {
  private genAI: GoogleGenAI;
  private config: GeminiConfig;

  constructor(apiKey?: string, config?: Partial<GeminiConfig>) {
    const finalApiKey = apiKey || process.env.GEMINI_API_KEY;
    
    if (!finalApiKey) {
      throw new DocumentProcessingError(
        'Gemini API key is required. Set GEMINI_API_KEY environment variable or pass it to constructor.'
      );
    }

    this.config = { ...DEFAULT_CONFIG, apiKey: finalApiKey, ...config };
    this.genAI = new GoogleGenAI({ apiKey: this.config.apiKey });
  }

  /**
   * Process raw text into canonical document format with fallback strategies
   */
  async processDocumentWithFallbacks(rawText: string): Promise<CanonicalDocument> {
    const strategies = [
      () => this.processDocument(rawText),
      () => this.processWithSimplifiedPrompt(rawText),
      () => this.processWithBasicStructure(rawText),
      () => this.createFallbackDocument(rawText),
    ];

    let lastError: Error | null = null;

    for (const strategy of strategies) {
      try {
        return await strategy();
      } catch (error) {
        lastError = error as Error;
        console.warn('Processing strategy failed:', error);
        continue;
      }
    }

    throw new DocumentProcessingError(
      'All processing strategies failed',
      lastError || undefined
    );
  }

  /**
   * Main document processing method with full AI analysis
   */
  async processDocument(rawText: string): Promise<CanonicalDocument> {
    if (!rawText || rawText.trim().length === 0) {
      throw new DocumentProcessingError('Raw text cannot be empty');
    }

    try {
      const prompt = this.buildAnalysisPrompt(rawText);
      
      const response = await this.genAI.models.generateContent({
        model: this.config.model,
        contents: prompt,
        config: {
          temperature: this.config.temperature,
          topP: this.config.topP,
          topK: this.config.topK,
          maxOutputTokens: this.config.maxOutputTokens,
          responseMimeType: "application/json",
          responseSchema: CANONICAL_DOCUMENT_SCHEMA,
        },
      });

      const jsonString = response.text;
      if (!jsonString) {
        throw new DocumentProcessingError('No response from Gemini AI');
      }

      const parsedDocument = JSON.parse(jsonString);
      return validateCanonicalDocument(parsedDocument);

    } catch (error) {
      if (error instanceof DocumentProcessingError) {
        throw error;
      }
      throw new DocumentProcessingError(
        'Failed to process document with Gemini AI',
        error as Error
      );
    }
  }

  /**
   * Simplified processing with reduced complexity
   */
  private async processWithSimplifiedPrompt(rawText: string): Promise<CanonicalDocument> {
    const simplifiedPrompt = this.buildSimplifiedPrompt(rawText);

    const response = await this.genAI.models.generateContent({
      model: this.config.model,
      contents: simplifiedPrompt,
      config: {
        temperature: 0.2,
        maxOutputTokens: 4096,
        responseMimeType: "application/json",
      },
    });

    const jsonString = response.text;
    if (!jsonString) {
      throw new DocumentProcessingError('No response from simplified processing');
    }

    const parsedDocument = JSON.parse(jsonString);
    return validateCanonicalDocument(parsedDocument);
  }

  /**
   * Basic structure processing as fallback
   */
  private async processWithBasicStructure(rawText: string): Promise<CanonicalDocument> {
    // Simple processing: split by paragraphs and create basic structure
    const paragraphs = rawText.split('\n\n').filter(p => p.trim().length > 0);
    
    const content = paragraphs.map((text, index) => ({
      id: `p-${index + 1}`,
      type: 'paragraph' as const,
      content: [
        {
          type: 'text' as const,
          text: text.trim(),
        },
      ],
    }));

    return {
      metadata: {
        documentType: 'other' as const,
        language: 'en',
        confidenceScore: 0.3,
      },
      content,
      version: '1.0',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
  }

  /**
   * Final fallback: create minimal document
   */
  private createFallbackDocument(rawText: string): CanonicalDocument {
    return {
      metadata: {
        documentType: 'other' as const,
        language: 'en',
        confidenceScore: 0.1,
      },
      content: [
        {
          id: 'p-fallback',
          type: 'paragraph',
          content: [
            {
              type: 'text',
              text: rawText,
            },
          ],
        },
      ],
      version: '1.0',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
  }

  /**
   * Build comprehensive analysis prompt
   */
  private buildAnalysisPrompt(rawText: string): string {
    return `
SYSTEM: You are a precise document analysis AI that converts raw text into structured JSON format. Your task is to analyze the provided text and extract it into a canonical document structure.

ROLE: Expert document analyzer specializing in content structure identification and data extraction.

TASK: Convert the following raw text into a structured JSON document following the exact schema provided. Analyze the content to identify document structure, formatting, and semantic elements.

INSTRUCTIONS:
1. Analyze the text to identify document structure (headings, paragraphs, lists, tables, etc.)
2. Extract inline formatting (bold, italic, underline) based on textual cues
3. Identify and structure any tabular data
4. Detect code blocks, quotes, and special content
5. Generate appropriate metadata including document type and confidence score
6. Assign unique IDs to all blocks and elements
7. Maintain original content while improving structure

CONSTRAINTS:
- Return only valid JSON matching the provided schema
- Use null for missing information
- Preserve original text content exactly
- Assign confidence scores based on clarity of structure identification
- Generate ISO 8601 timestamps for createdAt and updatedAt
- Use version "1.0" for initial processing

EXAMPLES:

<example>
<input>
# Financial Report Q4 2024

## Executive Summary
Our company performed **exceptionally well** in Q4 2024, with revenue increasing by 15% compared to the previous quarter.

### Key Metrics
- Revenue: $2.5M
- Profit: $450K
- Customer Growth: 12%
</input>
<output>
{
  "metadata": {
    "title": "Financial Report Q4 2024",
    "documentType": "report",
    "language": "en",
    "confidenceScore": 0.95
  },
  "content": [
    {
      "id": "h1-1",
      "type": "heading",
      "level": 1,
      "content": [
        {
          "type": "text",
          "text": "Financial Report Q4 2024"
        }
      ]
    },
    {
      "id": "h2-1",
      "type": "heading",
      "level": 2,
      "content": [
        {
          "type": "text",
          "text": "Executive Summary"
        }
      ]
    },
    {
      "id": "p-1",
      "type": "paragraph",
      "content": [
        {
          "type": "text",
          "text": "Our company performed "
        },
        {
          "type": "text",
          "text": "exceptionally well",
          "formatting": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": " in Q4 2024, with revenue increasing by 15% compared to the previous quarter."
        }
      ]
    },
    {
      "id": "h3-1",
      "type": "heading",
      "level": 3,
      "content": [
        {
          "type": "text",
          "text": "Key Metrics"
        }
      ]
    },
    {
      "id": "list-1",
      "type": "list",
      "listType": "bulleted",
      "items": [
        {
          "id": "li-1",
          "content": [
            {
              "type": "text",
              "text": "Revenue: $2.5M"
            }
          ]
        },
        {
          "id": "li-2",
          "content": [
            {
              "type": "text",
              "text": "Profit: $450K"
            }
          ]
        },
        {
          "id": "li-3",
          "content": [
            {
              "type": "text",
              "text": "Customer Growth: 12%"
            }
          ]
        }
      ]
    }
  ],
  "version": "1.0",
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:30:00Z"
}
</output>
</example>

INPUT TEXT:
${rawText}

OUTPUT JSON:`;
  }

  /**
   * Build simplified prompt for fallback processing
   */
  private buildSimplifiedPrompt(rawText: string): string {
    return `
Convert this text to structured JSON with metadata and content blocks:

Text: ${rawText}

Return JSON with:
1. metadata: { documentType, language, confidenceScore }
2. content: array of blocks with id, type, and content
3. version, createdAt, updatedAt

Focus on identifying paragraphs, headings, and lists. Keep it simple.
`;
  }
}

// =============================================================================
// Singleton Instance (Optional)
// =============================================================================

let geminiInstance: GeminiDocumentProcessor | null = null;

export const getGeminiProcessor = (apiKey?: string): GeminiDocumentProcessor => {
  if (!geminiInstance) {
    geminiInstance = new GeminiDocumentProcessor(apiKey);
  }
  return geminiInstance;
};

// =============================================================================
// Utility Functions
// =============================================================================

export const validateGeminiApiKey = async (apiKey: string): Promise<boolean> => {
  try {
    const processor = new GeminiDocumentProcessor(apiKey);
    await processor.processDocument('test');
    return true;
  } catch (error) {
    return false;
  }
};

export const estimateProcessingTime = (textLength: number): number => {
  // Rough estimate: 1-3 seconds per 1000 characters
  return Math.max(1000, Math.min(30000, textLength * 2));
};

// =============================================================================
// Export Types
// =============================================================================

export type { GeminiConfig };













// src/lib/adapters/canonical-to-tiptap.ts - CREATED: 2025-07-07 - Canonical to Tiptap JSON adapter

import { JSONContent } from "@tiptap/core";
import {
  CanonicalDocument,
  CanonicalBlock,
  HeadingBlock,
  ParagraphBlock,
  ListBlock,
  TableBlock,
  ImageBlock,
  CodeBlock,
  BlockquoteBlock,
  MultipleChoiceBlock,
  DividerBlock,
  InlineContent,
  TextContent,
  FormattedTextContent,
  LinkContent,
  BreakContent,
  ListItem,
} from "@/types/document";

// =============================================================================
// Main Adapter Class
// =============================================================================

export class CanonicalToTiptapAdapter {
  /**
   * Transform a canonical document to Tiptap JSON format
   */
  transform(canonicalDoc: CanonicalDocument): JSONContent {
    return {
      type: "doc",
      content: canonicalDoc.content.map((block) => this.transformBlock(block)),
    };
  }

  /**
   * Transform a single canonical block to Tiptap format
   */
  private transformBlock(block: CanonicalBlock): JSONContent {
    switch (block.type) {
      case "heading":
        return this.transformHeading(block);
      case "paragraph":
        return this.transformParagraph(block);
      case "list":
        return this.transformList(block);
      case "table":
        return this.transformTable(block);
      case "image":
        return this.transformImage(block);
      case "codeBlock":
        return this.transformCodeBlock(block);
      case "blockquote":
        return this.transformBlockquote(block);
      case "multipleChoice":
        return this.transformMultipleChoice(block);
      case "divider":
        return this.transformDivider(block);
      default:
        // Fallback to paragraph for unknown types
        return this.transformParagraph(block as ParagraphBlock);
    }
  }

  // =============================================================================
  // Block Transformers
  // =============================================================================

  private transformHeading(block: HeadingBlock): JSONContent {
    return {
      type: "heading",
      attrs: {
        level: block.level,
      },
      content: this.transformInlineContent(block.content),
    };
  }

  private transformParagraph(block: ParagraphBlock): JSONContent {
    return {
      type: "paragraph",
      content: this.transformInlineContent(block.content),
    };
  }

  private transformList(block: ListBlock): JSONContent {
    const listType = block.listType === "numbered" ? "orderedList" : "bulletList";

    return {
      type: listType,
      content: block.items.map((item) => this.transformListItem(item, block.listType)),
    };
  }

  private transformListItem(item: ListItem, listType: "bulleted" | "numbered"): JSONContent {
    const content: JSONContent[] = [
      {
        type: "paragraph",
        content: this.transformInlineContent(item.content),
      },
    ];

    // Handle nested lists
    if (item.items && item.items.length > 0) {
      const nestedListType = listType === "numbered" ? "orderedList" : "bulletList";
      content.push({
        type: nestedListType,
        content: item.items.map((nestedItem) => this.transformListItem(nestedItem, listType)),
      });
    }

    return {
      type: "listItem",
      content,
    };
  }

  private transformTable(block: TableBlock): JSONContent {
    // Create header row
    const headerRow: JSONContent = {
      type: "tableRow",
      content: block.headers.cells.map((cell) => ({
        type: "tableHeader",
        attrs: {
          colspan: cell.colspan || 1,
          rowspan: cell.rowspan || 1,
        },
        content: [
          {
            type: "paragraph",
            content: this.transformInlineContent(cell.content),
          },
        ],
      })),
    };

    // Create body rows
    const bodyRows: JSONContent[] = block.rows.map((row) => ({
      type: "tableRow",
      content: row.cells.map((cell) => ({
        type: "tableCell",
        attrs: {
          colspan: cell.colspan || 1,
          rowspan: cell.rowspan || 1,
        },
        content: [
          {
            type: "paragraph",
            content: this.transformInlineContent(cell.content),
          },
        ],
      })),
    }));

    return {
      type: "table",
      content: [headerRow, ...bodyRows],
    };
  }

  private transformImage(block: ImageBlock): JSONContent {
    return {
      type: "image",
      attrs: {
        src: block.src,
        alt: block.alt || "",
        title: block.caption || "",
        width: block.width,
        height: block.height,
      },
    };
  }

  private transformCodeBlock(block: CodeBlock): JSONContent {
    return {
      type: "codeBlock",
      attrs: {
        language: block.language || null,
      },
      content: [
        {
          type: "text",
          text: block.content,
        },
      ],
    };
  }

  private transformBlockquote(block: BlockquoteBlock): JSONContent {
    return {
      type: "blockquote",
      content: block.content.map((childBlock) => this.transformBlock(childBlock)),
    };
  }

  private transformMultipleChoice(block: MultipleChoiceBlock): JSONContent {
    // Custom node for multiple choice questions
    // This might need to be implemented as a custom Tiptap extension
    return {
      type: "multipleChoice",
      attrs: {
        question: this.transformInlineContent(block.question),
        options: block.options.map((option) => ({
          id: option.id,
          content: this.transformInlineContent(option.content),
          isCorrect: option.isCorrect || false,
        })),
        correctAnswer: block.correctAnswer,
      },
    };
  }

  private transformDivider(block: DividerBlock): JSONContent {
    return {
      type: "horizontalRule",
      attrs: {
        style: block.style || "solid",
      },
    };
  }

  // =============================================================================
  // Inline Content Transformers
  // =============================================================================

  private transformInlineContent(content: InlineContent[]): JSONContent[] {
    return content.map((item) => {
      switch (item.type) {
        case "text":
          return this.transformText(item);
        case "link":
          return this.transformLink(item);
        case "break":
          return this.transformBreak(item);
        default:
          // Fallback for unknown types
          return {
            type: "text",
            text: (item as any).text || "",
          };
      }
    });
  }

  private transformText(item: TextContent | FormattedTextContent): JSONContent {
    const marks: any[] = [];

    // Check if item has formatting
    if ("formatting" in item && item.formatting) {
      const { formatting } = item;
      
      if (formatting.bold) marks.push({ type: "bold" });
      if (formatting.italic) marks.push({ type: "italic" });
      if (formatting.underline) marks.push({ type: "underline" });
      if (formatting.strikethrough) marks.push({ type: "strike" });
      if (formatting.code) marks.push({ type: "code" });
      if (formatting.superscript) marks.push({ type: "superscript" });
      if (formatting.subscript) marks.push({ type: "subscript" });
    }

    const result: JSONContent = {
      type: "text",
      text: item.text,
    };

    if (marks.length > 0) {
      result.marks = marks;
    }

    return result;
  }

  private transformLink(item: LinkContent): JSONContent {
    return {
      type: "text",
      text: item.text,
      marks: [
        {
          type: "link",
          attrs: {
            href: item.url,
            title: item.title || null,
          },
        },
      ],
    };
  }

  private transformBreak(item: BreakContent): JSONContent {
    return {
      type: item.breakType === "hard" ? "hardBreak" : "softBreak",
    };
  }
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Transform canonical document to Tiptap JSON (functional approach)
 */
export const canonicalToTiptapJson = (canonicalDoc: CanonicalDocument): JSONContent => {
  const adapter = new CanonicalToTiptapAdapter();
  return adapter.transform(canonicalDoc);
};

/**
 * Transform a single canonical block to Tiptap JSON
 */
export const canonicalBlockToTiptapJson = (block: CanonicalBlock): JSONContent => {
  const adapter = new CanonicalToTiptapAdapter();
  return (adapter as any).transformBlock(block);
};

/**
 * Validate that a Tiptap JSON structure is valid
 */
export const validateTiptapJson = (json: JSONContent): boolean => {
  try {
    // Basic validation - check required properties
    if (!json || typeof json !== "object") return false;
    if (!json.type || typeof json.type !== "string") return false;
    
    // If it has content, validate recursively
    if (json.content && Array.isArray(json.content)) {
      return json.content.every(validateTiptapJson);
    }
    
    return true;
  } catch {
    return false;
  }
};

/**
 * Get all text content from a Tiptap JSON structure
 */
export const extractTextFromTiptapJson = (json: JSONContent): string => {
  if (json.type === "text") {
    return json.text || "";
  }
  
  if (json.content && Array.isArray(json.content)) {
    return json.content.map(extractTextFromTiptapJson).join("");
  }
  
  return "";
};

/**
 * Count blocks in a Tiptap JSON structure
 */
export const countTiptapBlocks = (json: JSONContent): number => {
  let count = 1; // Count the current block
  
  if (json.content && Array.isArray(json.content)) {
    count += json.content.reduce((sum, child) => sum + countTiptapBlocks(child), 0);
  }
  
  return count;
};

// =============================================================================
// Error Handling
// =============================================================================

export class TiptapTransformationError extends Error {
  constructor(message: string, public originalBlock?: CanonicalBlock) {
    super(message);
    this.name = "TiptapTransformationError";
  }
}

/**
 * Safe transformation with error handling
 */
export const safeCanonicalToTiptapJson = (
  canonicalDoc: CanonicalDocument
): { success: true; data: JSONContent } | { success: false; error: string } => {
  try {
    const result = canonicalToTiptapJson(canonicalDoc);
    return { success: true, data: result };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown transformation error",
    };
  }
};












// src/lib/adapters/tiptap-to-pdfme.ts - CREATED: 2025-07-07 - Tiptap to pdfme adapter

import { JSONContent } from "@tiptap/core";
import { Template, Schema, PdfGenerationInput } from "@/types/template";

// =============================================================================
// pdfme Document Interface
// =============================================================================

export interface PdfmeDocument {
  template: Template;
  inputs: PdfGenerationInput[];
}

export interface PdfmeOptions {
  startY?: number;
  pageWidth?: number;
  pageHeight?: number;
  margin?: number;
  defaultFont?: string;
  defaultFontSize?: number;
}

// =============================================================================
// Main Adapter Class
// =============================================================================

export class TiptapToPdfmeAdapter {
  private currentY: number = 20;
  private pageWidth: number = 210; // A4 width in mm
  private pageHeight: number = 297; // A4 height in mm
  private margin: number = 20;
  private defaultFont: string = "NotoSansCJK-Regular";
  private defaultFontSize: number = 12;

  constructor(options?: PdfmeOptions) {
    if (options) {
      this.currentY = options.startY || 20;
      this.pageWidth = options.pageWidth || 210;
      this.pageHeight = options.pageHeight || 297;
      this.margin = options.margin || 20;
      this.defaultFont = options.defaultFont || "NotoSansCJK-Regular";
      this.defaultFontSize = options.defaultFontSize || 12;
    }
  }

  /**
   * Transform Tiptap JSON to pdfme template and inputs
   */
  transform(tiptapDoc: JSONContent, options?: PdfmeOptions): PdfmeDocument {
    // Reset position for new document
    this.currentY = options?.startY || 20;

    if (options) {
      this.pageWidth = options.pageWidth || this.pageWidth;
      this.pageHeight = options.pageHeight || this.pageHeight;
      this.margin = options.margin || this.margin;
      this.defaultFont = options.defaultFont || this.defaultFont;
      this.defaultFontSize = options.defaultFontSize || this.defaultFontSize;
    }

    const schemas: Schema[] = [];
    const inputs: PdfGenerationInput = {};

    if (tiptapDoc.content) {
      tiptapDoc.content.forEach((block, index) => {
        const blockResult = this.transformBlock(block, index);
        schemas.push(...blockResult.schemas);
        Object.assign(inputs, blockResult.inputs);
      });
    }

    const template: Template = {
      schemas: [schemas],
    };

    return {
      template,
      inputs: [inputs],
    };
  }

  // =============================================================================
  // Block Transformers
  // =============================================================================

  private transformBlock(
    block: JSONContent,
    index: number
  ): { schemas: Schema[]; inputs: PdfGenerationInput } {
    switch (block.type) {
      case "heading":
        return this.transformHeading(block, index);
      case "paragraph":
        return this.transformParagraph(block, index);
      case "bulletList":
      case "orderedList":
        return this.transformList(block, index);
      case "table":
        return this.transformTable(block, index);
      case "image":
        return this.transformImage(block, index);
      case "codeBlock":
        return this.transformCodeBlock(block, index);
      case "blockquote":
        return this.transformBlockquote(block, index);
      case "horizontalRule":
        return this.transformHorizontalRule(block, index);
      default:
        return this.transformParagraph(block, index);
    }
  }

  private transformHeading(
    block: JSONContent,
    index: number
  ): { schemas: Schema[]; inputs: PdfGenerationInput } {
    const fieldName = `heading_${index}`;
    const level = block.attrs?.level || 1;
    const fontSize = this.getHeadingFontSize(level);
    const text = this.extractTextFromContent(block.content);

    const schema: Schema = {
      name: fieldName,
      type: "text",
      position: { x: this.margin, y: this.currentY },
      width: this.pageWidth - this.margin * 2,
      height: fontSize * 1.2,
      fontSize,
      fontName: this.defaultFont,
      fontColor: "#000000",
      alignment: "left",
      verticalAlignment: "top",
    };

    this.currentY += fontSize * 1.5;

    return {
      schemas: [schema],
      inputs: { [fieldName]: text },
    };
  }

  private transformParagraph(
    block: JSONContent,
    index: number
  ): { schemas: Schema[]; inputs: PdfGenerationInput } {
    const fieldName = `paragraph_${index}`;
    const text = this.extractTextFromContent(block.content);
    const estimatedHeight = this.estimateTextHeight(text, this.defaultFontSize);

    const schema: Schema = {
      name: fieldName,
      type: "text",
      position: { x: this.margin, y: this.currentY },
      width: this.pageWidth - this.margin * 2,
      height: estimatedHeight,
      fontSize: this.defaultFontSize,
      fontName: this.defaultFont,
      fontColor: "#000000",
      alignment: "left",
      verticalAlignment: "top",
      lineHeight: 1.5,
    };

    this.currentY += estimatedHeight + 5;

    return {
      schemas: [schema],
      inputs: { [fieldName]: text },
    };
  }

  private transformList(
    block: JSONContent,
    index: number
  ): { schemas: Schema[]; inputs: PdfGenerationInput } {
    const schemas: Schema[] = [];
    const inputs: PdfGenerationInput = {};

    if (block.content) {
      block.content.forEach((item, itemIndex) => {
        const fieldName = `list_${index}_${itemIndex}`;
        const text = this.extractTextFromListItem(item);
        const prefix = block.type === "orderedList" ? `${itemIndex + 1}. ` : "â€¢ ";
        const fullText = prefix + text;

        const estimatedHeight = this.estimateTextHeight(fullText, this.defaultFontSize);

        const schema: Schema = {
          name: fieldName,
          type: "text",
          position: { x: this.margin + 10, y: this.currentY },
          width: this.pageWidth - this.margin * 2 - 10,
          height: estimatedHeight,
          fontSize: this.defaultFontSize,
          fontName: this.defaultFont,
          fontColor: "#000000",
          alignment: "left",
          verticalAlignment: "top",
          lineHeight: 1.5,
        };

        schemas.push(schema);
        inputs[fieldName] = fullText;
        this.currentY += estimatedHeight + 3;
      });
    }

    this.currentY += 10; // Add spacing after list

    return { schemas, inputs };
  }

  private transformTable(
    block: JSONContent,
    index: number
  ): { schemas: Schema[]; inputs: PdfGenerationInput } {
    const fieldName = `table_${index}`;
    const tableData = this.extractTableData(block);

    const estimatedHeight = (tableData.length + 1) * 20; // Rough estimate

    const schema: Schema = {
      name: fieldName,
      type: "table",
      position: { x: this.margin, y: this.currentY },
      width: this.pageWidth - this.margin * 2,
      height: estimatedHeight,
      fontSize: 10,
      fontName: this.defaultFont,
      fontColor: "#000000",
      borderWidth: 1,
      borderColor: "#000000",
    };

    this.currentY += estimatedHeight + 10;

    return {
      schemas: [schema],
      inputs: { [fieldName]: tableData },
    };
  }

  private transformImage(
    block: JSONContent,
    index: number
  ): { schemas: Schema[]; inputs: PdfGenerationInput } {
    const fieldName = `image_${index}`;
    const src = block.attrs?.src || "";
    const width = block.attrs?.width || 100;
    const height = block.attrs?.height || 100;

    const schema: Schema = {
      name: fieldName,
      type: "image",
      position: { x: this.margin, y: this.currentY },
      width: Math.min(width, this.pageWidth - this.margin * 2),
      height: height,
      alignment: "left",
    };

    this.currentY += height + 10;

    return {
      schemas: [schema],
      inputs: { [fieldName]: src },
    };
  }

  private transformCodeBlock(
    block: JSONContent,
    index: number
  ): { schemas: Schema[]; inputs: PdfGenerationInput } {
    const fieldName = `code_${index}`;
    const text = this.extractTextFromContent(block.content);
    const estimatedHeight = this.estimateTextHeight(text, 10);

    const schema: Schema = {
      name: fieldName,
      type: "text",
      position: { x: this.margin, y: this.currentY },
      width: this.pageWidth - this.margin * 2,
      height: estimatedHeight,
      fontSize: 10,
      fontName: "CourierPrime-Regular",
      fontColor: "#000000",
      backgroundColor: "#f5f5f5",
      alignment: "left",
      verticalAlignment: "top",
      lineHeight: 1.2,
    };

    this.currentY += estimatedHeight + 10;

    return {
      schemas: [schema],
      inputs: { [fieldName]: text },
    };
  }

  private transformBlockquote(
    block: JSONContent,
    index: number
  ): { schemas: Schema[]; inputs: PdfGenerationInput } {
    const fieldName = `blockquote_${index}`;
    const text = this.extractTextFromContent(block.content);
    const estimatedHeight = this.estimateTextHeight(text, this.defaultFontSize);

    const schema: Schema = {
      name: fieldName,
      type: "text",
      position: { x: this.margin + 20, y: this.currentY },
      width: this.pageWidth - this.margin * 2 - 20,
      height: estimatedHeight,
      fontSize: this.defaultFontSize,
      fontName: this.defaultFont,
      fontColor: "#666666",
      alignment: "left",
      verticalAlignment: "top",
      lineHeight: 1.5,
    };

    this.currentY += estimatedHeight + 10;

    return {
      schemas: [schema],
      inputs: { [fieldName]: text },
    };
  }

  private transformHorizontalRule(
    block: JSONContent,
    index: number
  ): { schemas: Schema[]; inputs: PdfGenerationInput } {
    const fieldName = `hr_${index}`;

    const schema: Schema = {
      name: fieldName,
      type: "line",
      position: { x: this.margin, y: this.currentY },
      width: this.pageWidth - this.margin * 2,
      height: 1,
      borderWidth: 1,
      borderColor: "#cccccc",
    };

    this.currentY += 20;

    return {
      schemas: [schema],
      inputs: { [fieldName]: "" },
    };
  }

  // =============================================================================
  // Helper Methods
  // =============================================================================

  private extractTextFromContent(content: JSONContent[] | undefined): string {
    if (!content) return "";

    return content
      .map((item) => {
        if (item.type === "text") {
          return item.text || "";
        } else if (item.content) {
          return this.extractTextFromContent(item.content);
        }
        return "";
      })
      .join("");
  }

  private extractTextFromListItem(item: JSONContent): string {
    if (item.content) {
      return item.content
        .map((block) => {
          if (block.type === "paragraph" && block.content) {
            return this.extractTextFromContent(block.content);
          }
          return "";
        })
        .join("");
    }
    return "";
  }

  private extractTableData(block: JSONContent): string[][] {
    if (!block.content) return [];

    return block.content.map((row) => {
      if (row.content) {
        return row.content.map((cell) => {
          if (cell.content) {
            return this.extractTextFromContent(cell.content);
          }
          return "";
        });
      }
      return [];
    });
  }

  private getHeadingFontSize(level: number): number {
    const sizes = { 1: 24, 2: 20, 3: 16, 4: 14, 5: 12, 6: 10 };
    return sizes[level as keyof typeof sizes] || this.defaultFontSize;
  }

  private estimateTextHeight(text: string, fontSize: number): number {
    const lineHeight = fontSize * 1.5;
    const charsPerLine = Math.floor((this.pageWidth - this.margin * 2) / (fontSize * 0.6));
    const lines = Math.ceil(text.length / charsPerLine);
    return Math.max(lines * lineHeight, fontSize);
  }
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Transform Tiptap JSON to pdfme format (functional approach)
 */
export const tiptapToPdfmeInputs = (
  tiptapDoc: JSONContent,
  options?: PdfmeOptions
): PdfmeDocument => {
  const adapter = new TiptapToPdfmeAdapter(options);
  return adapter.transform(tiptapDoc, options);
};

/**
 * Create a basic template for text documents
 */
export const createBasicTextTemplate = (options?: PdfmeOptions): Template => {
  const pageWidth = options?.pageWidth || 210;
  const pageHeight = options?.pageHeight || 297;
  const margin = options?.margin || 20;

  return {
    schemas: [
      [
        {
          name: "title",
          type: "text",
          position: { x: margin, y: 20 },
          width: pageWidth - margin * 2,
          height: 20,
          fontSize: 18,
          fontName: "NotoSansCJK-Regular",
          alignment: "center",
          fontColor: "#000000",
        },
        {
          name: "content",
          type: "text",
          position: { x: margin, y: 50 },
          width: pageWidth - margin * 2,
          height: pageHeight - 70,
          fontSize: 12,
          fontName: "NotoSansCJK-Regular",
          lineHeight: 1.5,
          fontColor: "#000000",
        },
      ],
    ],
  };
};

/**
 * Estimate the number of pages needed for content
 */
export const estimatePageCount = (
  tiptapDoc: JSONContent,
  options?: PdfmeOptions
): number => {
  const text = extractAllText(tiptapDoc);
  const pageHeight = options?.pageHeight || 297;
  const margin = options?.margin || 20;
  const fontSize = options?.defaultFontSize || 12;

  const usableHeight = pageHeight - margin * 2;
  const linesPerPage = Math.floor(usableHeight / (fontSize * 1.5));
  const charsPerLine = Math.floor((options?.pageWidth || 210) / (fontSize * 0.6));
  const charsPerPage = linesPerPage * charsPerLine;

  return Math.ceil(text.length / charsPerPage);
};

/**
 * Extract all text from Tiptap JSON
 */
export const extractAllText = (json: JSONContent): string => {
  if (json.type === "text") {
    return json.text || "";
  }

  if (json.content && Array.isArray(json.content)) {
    return json.content.map(extractAllText).join(" ");
  }

  return "";
};

/**
 * Validate pdfme template structure
 */
export const validatePdfmeTemplate = (template: Template): boolean => {
  try {
    if (!template.schemas || !Array.isArray(template.schemas)) return false;

    return template.schemas.every((page) => {
      if (!Array.isArray(page)) return false;
      return page.every((schema) => {
        return (
          schema.name &&
          schema.type &&
          schema.position &&
          typeof schema.width === "number" &&
          typeof schema.height === "number"
        );
      });
    });
  } catch {
    return false;
  }
};

// =============================================================================
// Error Handling
// =============================================================================

export class PdfmeTransformationError extends Error {
  constructor(message: string, public originalBlock?: JSONContent) {
    super(message);
    this.name = "PdfmeTransformationError";
  }
}

/**
 * Safe transformation with error handling
 */
export const safeTiptapToPdfmeInputs = (
  tiptapDoc: JSONContent,
  options?: PdfmeOptions
): { success: true; data: PdfmeDocument } | { success: false; error: string } => {
  try {
    const result = tiptapToPdfmeInputs(tiptapDoc, options);
    return { success: true, data: result };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown transformation error",
    };
  }
};














// src/app/api/analyze/route.ts - CREATED: 2025-07-07 - Document analysis API endpoint

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { GeminiDocumentProcessor } from '@/lib/services/gemini';
import { CanonicalToTiptapAdapter } from '@/lib/adapters/canonical-to-tiptap';
import { 
  CanonicalDocument, 
  DocumentProcessingError,
  validateCanonicalDocument 
} from '@/types/document';

// =============================================================================
// Request/Response Schemas
// =============================================================================

const AnalyzeRequestSchema = z.object({
  text: z.string().min(1, 'Text cannot be empty').max(50000, 'Text too long (max 50k characters)'),
  options: z.object({
    language: z.string().optional(),
    documentType: z.enum(['report', 'article', 'form', 'contract', 'other']).optional(),
    enableFallback: z.boolean().default(true),
  }).optional(),
});

interface AnalyzeResponse {
  success: boolean;
  data?: {
    canonical: CanonicalDocument;
    tiptap: any;
    metadata: {
      processingTime: number;
      textLength: number;
      blockCount: number;
      confidenceScore: number;
    };
  };
  error?: string;
  details?: any;
}

// =============================================================================
// POST Handler - Document Analysis
// =============================================================================

export async function POST(request: NextRequest): Promise<NextResponse<AnalyzeResponse>> {
  const startTime = Date.now();

  try {
    // Parse and validate request body
    const body = await request.json().catch(() => null);
    
    if (!body) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid JSON in request body',
        },
        { status: 400 }
      );
    }

    const validationResult = AnalyzeRequestSchema.safeParse(body);
    
    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request format',
          details: validationResult.error.errors,
        },
        { status: 400 }
      );
    }

    const { text, options } = validationResult.data;

    // Check API key
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
      return NextResponse.json(
        {
          success: false,
          error: 'Server configuration error: Missing AI API key',
        },
        { status: 500 }
      );
    }

    // Initialize processors
    const geminiProcessor = new GeminiDocumentProcessor(apiKey);
    const tiptapAdapter = new CanonicalToTiptapAdapter();

    // Process document with Gemini AI
    let canonicalDocument: CanonicalDocument;
    
    try {
      if (options?.enableFallback !== false) {
        canonicalDocument = await geminiProcessor.processDocumentWithFallbacks(text);
      } else {
        canonicalDocument = await geminiProcessor.processDocument(text);
      }
    } catch (error) {
      console.error('Document processing failed:', error);
      
      return NextResponse.json(
        {
          success: false,
          error: error instanceof DocumentProcessingError 
            ? error.message 
            : 'Failed to process document',
          details: error instanceof Error ? error.message : undefined,
        },
        { status: 500 }
      );
    }

    // Transform to Tiptap format
    let tiptapDocument;
    try {
      tiptapDocument = tiptapAdapter.transform(canonicalDocument);
    } catch (error) {
      console.error('Tiptap transformation failed:', error);
      
      return NextResponse.json(
        {
          success: false,
          error: 'Failed to convert document to editor format',
          details: error instanceof Error ? error.message : undefined,
        },
        { status: 500 }
      );
    }

    // Calculate metadata
    const processingTime = Date.now() - startTime;
    const blockCount = canonicalDocument.content.length;
    const confidenceScore = canonicalDocument.metadata.confidenceScore;

    // Return successful response
    return NextResponse.json(
      {
        success: true,
        data: {
          canonical: canonicalDocument,
          tiptap: tiptapDocument,
          metadata: {
            processingTime,
            textLength: text.length,
            blockCount,
            confidenceScore,
          },
        },
      },
      { status: 200 }
    );

  } catch (error) {
    console.error('Unexpected error in analyze endpoint:', error);

    return NextResponse.json(
      {
        success: false,
        error: 'Internal server error',
        details: process.env.NODE_ENV === 'development' 
          ? (error instanceof Error ? error.message : 'Unknown error')
          : undefined,
      },
      { status: 500 }
    );
  }
}

// =============================================================================
// GET Handler - Health Check
// =============================================================================

export async function GET(): Promise<NextResponse> {
  try {
    // Check if Gemini API key is configured
    const hasApiKey = !!process.env.GEMINI_API_KEY;
    
    return NextResponse.json(
      {
        status: 'ok',
        endpoint: 'analyze',
        configured: hasApiKey,
        timestamp: new Date().toISOString(),
        version: '1.0.0',
      },
      { status: 200 }
    );
  } catch (error) {
    return NextResponse.json(
      {
        status: 'error',
        error: 'Health check failed',
      },
      { status: 500 }
    );
  }
}

// =============================================================================
// OPTIONS Handler - CORS Support
// =============================================================================

export async function OPTIONS(): Promise<NextResponse> {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  });
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Rate limiting check (simple implementation)
 */
function checkRateLimit(request: NextRequest): boolean {
  // In production, implement proper rate limiting with Redis or similar
  // For now, just return true
  return true;
}

/**
 * Log request for monitoring
 */
function logRequest(
  request: NextRequest, 
  textLength: number, 
  processingTime: number
): void {
  if (process.env.NODE_ENV === 'development') {
    console.log(`[ANALYZE] ${request.method} - ${textLength} chars - ${processingTime}ms`);
  }
}

/**
 * Sanitize text input
 */
function sanitizeText(text: string): string {
  // Remove potentially harmful content
  return text
    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '') // Remove control characters
    .trim();
}

// =============================================================================
// Error Response Helpers
// =============================================================================

export function createErrorResponse(
  error: string,
  status: number = 400,
  details?: any
): NextResponse<AnalyzeResponse> {
  return NextResponse.json(
    {
      success: false,
      error,
      details,
    },
    { status }
  );
}

export function createSuccessResponse(
  data: AnalyzeResponse['data']
): NextResponse<AnalyzeResponse> {
  return NextResponse.json(
    {
      success: true,
      data,
    },
    { status: 200 }
  );
}













// src/app/api/templates/route.ts - CREATED: 2025-07-07 - Templates management API endpoint

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { supabase } from '@/lib/supabase';
import { 
  PdfTemplate, 
  TemplateRow, 
  validateTemplate, 
  validatePdfTemplate,
  createBasicTextTemplate,
  TemplateValidationError 
} from '@/types/template';

// =============================================================================
// Request/Response Schemas
// =============================================================================

const CreateTemplateSchema = z.object({
  name: z.string().min(1).max(255),
  description: z.string().optional(),
  template_json: z.any(), // Will be validated separately
  is_public: z.boolean().default(false),
  category: z.string().optional(),
  tags: z.array(z.string()).optional(),
});

const UpdateTemplateSchema = z.object({
  name: z.string().min(1).max(255).optional(),
  description: z.string().optional(),
  template_json: z.any().optional(),
  is_public: z.boolean().optional(),
  category: z.string().optional(),
  tags: z.array(z.string()).optional(),
});

interface TemplatesResponse {
  success: boolean;
  data?: PdfTemplate[] | PdfTemplate;
  error?: string;
  details?: any;
  pagination?: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// =============================================================================
// GET Handler - Retrieve Templates
// =============================================================================

export async function GET(request: NextRequest): Promise<NextResponse<TemplatesResponse>> {
  try {
    const { searchParams } = new URL(request.url);
    
    // Parse query parameters
    const page = parseInt(searchParams.get('page') || '1', 10);
    const limit = Math.min(parseInt(searchParams.get('limit') || '20', 10), 100);
    const category = searchParams.get('category');
    const isPublic = searchParams.get('public') === 'true';
    const search = searchParams.get('search');
    const userId = searchParams.get('user_id'); // For user-specific templates

    // Build query
    let query = supabase
      .from('templates')
      .select('*', { count: 'exact' });

    // Apply filters
    if (isPublic) {
      query = query.eq('is_public', true);
    } else if (userId) {
      query = query.eq('user_id', userId);
    }

    if (category) {
      query = query.eq('category', category);
    }

    if (search) {
      query = query.or(`name.ilike.%${search}%,description.ilike.%${search}%`);
    }

    // Apply pagination
    const from = (page - 1) * limit;
    const to = from + limit - 1;
    query = query.range(from, to);

    // Order by updated_at desc
    query = query.order('updated_at', { ascending: false });

    const { data, error, count } = await query;

    if (error) {
      console.error('Supabase query error:', error);
      return NextResponse.json(
        {
          success: false,
          error: 'Failed to fetch templates',
          details: error.message,
        },
        { status: 500 }
      );
    }

    // Transform to PdfTemplate format
    const templates: PdfTemplate[] = (data || []).map(transformRowToPdfTemplate);

    const totalPages = Math.ceil((count || 0) / limit);

    return NextResponse.json(
      {
        success: true,
        data: templates,
        pagination: {
          page,
          limit,
          total: count || 0,
          totalPages,
        },
      },
      { status: 200 }
    );

  } catch (error) {
    console.error('Unexpected error in templates GET:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Internal server error',
      },
      { status: 500 }
    );
  }
}

// =============================================================================
// POST Handler - Create Template
// =============================================================================

export async function POST(request: NextRequest): Promise<NextResponse<TemplatesResponse>> {
  try {
    // Parse request body
    const body = await request.json().catch(() => null);
    
    if (!body) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid JSON in request body',
        },
        { status: 400 }
      );
    }

    // Validate basic structure
    const validationResult = CreateTemplateSchema.safeParse(body);
    
    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request format',
          details: validationResult.error.errors,
        },
        { status: 400 }
      );
    }

    const { name, description, template_json, is_public, category, tags } = validationResult.data;

    // Validate template JSON structure
    try {
      validateTemplate(template_json);
    } catch (error) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid template JSON structure',
          details: error instanceof Error ? error.message : 'Template validation failed',
        },
        { status: 400 }
      );
    }

    // For now, we'll use a placeholder user_id since auth isn't implemented
    // In production, get this from authentication
    const user_id = 'anonymous'; // TODO: Replace with actual user authentication

    // Insert into database
    const { data, error } = await supabase
      .from('templates')
      .insert({
        name,
        description,
        template_json,
        user_id,
        is_public: is_public || false,
        category,
        tags,
      })
      .select()
      .single();

    if (error) {
      console.error('Supabase insert error:', error);
      return NextResponse.json(
        {
          success: false,
          error: 'Failed to create template',
          details: error.message,
        },
        { status: 500 }
      );
    }

    const createdTemplate = transformRowToPdfTemplate(data);

    return NextResponse.json(
      {
        success: true,
        data: createdTemplate,
      },
      { status: 201 }
    );

  } catch (error) {
    console.error('Unexpected error in templates POST:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Internal server error',
      },
      { status: 500 }
    );
  }
}

// =============================================================================
// PUT Handler - Update Template
// =============================================================================

export async function PUT(request: NextRequest): Promise<NextResponse<TemplatesResponse>> {
  try {
    const { searchParams } = new URL(request.url);
    const templateId = searchParams.get('id');

    if (!templateId) {
      return NextResponse.json(
        {
          success: false,
          error: 'Template ID is required',
        },
        { status: 400 }
      );
    }

    // Parse request body
    const body = await request.json().catch(() => null);
    
    if (!body) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid JSON in request body',
        },
        { status: 400 }
      );
    }

    // Validate update data
    const validationResult = UpdateTemplateSchema.safeParse(body);
    
    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request format',
          details: validationResult.error.errors,
        },
        { status: 400 }
      );
    }

    const updateData = validationResult.data;

    // Validate template JSON if provided
    if (updateData.template_json) {
      try {
        validateTemplate(updateData.template_json);
      } catch (error) {
        return NextResponse.json(
          {
            success: false,
            error: 'Invalid template JSON structure',
            details: error instanceof Error ? error.message : 'Template validation failed',
          },
          { status: 400 }
        );
      }
    }

    // Update in database
    const { data, error } = await supabase
      .from('templates')
      .update({
        ...updateData,
        updated_at: new Date().toISOString(),
      })
      .eq('id', templateId)
      .select()
      .single();

    if (error) {
      console.error('Supabase update error:', error);
      return NextResponse.json(
        {
          success: false,
          error: 'Failed to update template',
          details: error.message,
        },
        { status: 500 }
      );
    }

    const updatedTemplate = transformRowToPdfTemplate(data);

    return NextResponse.json(
      {
        success: true,
        data: updatedTemplate,
      },
      { status: 200 }
    );

  } catch (error) {
    console.error('Unexpected error in templates PUT:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Internal server error',
      },
      { status: 500 }
    );
  }
}

// =============================================================================
// DELETE Handler - Delete Template
// =============================================================================

export async function DELETE(request: NextRequest): Promise<NextResponse<TemplatesResponse>> {
  try {
    const { searchParams } = new URL(request.url);
    const templateId = searchParams.get('id');

    if (!templateId) {
      return NextResponse.json(
        {
          success: false,
          error: 'Template ID is required',
        },
        { status: 400 }
      );
    }

    // Delete from database
    const { error } = await supabase
      .from('templates')
      .delete()
      .eq('id', templateId);

    if (error) {
      console.error('Supabase delete error:', error);
      return NextResponse.json(
        {
          success: false,
          error: 'Failed to delete template',
          details: error.message,
        },
        { status: 500 }
      );
    }

    return NextResponse.json(
      {
        success: true,
        data: undefined, // No data returned for delete
      },
      { status: 200 }
    );

  } catch (error) {
    console.error('Unexpected error in templates DELETE:', error);
    return NextResponse.json(
      {
        success: false,
        error: 'Internal server error',
      },
      { status: 500 }
    );
  }
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Transform database row to PdfTemplate format
 */
function transformRowToPdfTemplate(row: TemplateRow): PdfTemplate {
  return {
    id: row.id,
    name: row.name,
    description: row.description,
    template_json: row.template_json,
    user_id: row.user_id,
    created_at: row.created_at,
    updated_at: row.updated_at,
  };
}

/**
 * Create default templates for new users
 */
export async function createDefaultTemplates(userId: string): Promise<void> {
  const defaultTemplates = [
    {
      name: 'Basic Text Document',
      description: 'Simple template for text documents with title and content',
      template_json: createBasicTextTemplate(),
      user_id: userId,
      is_public: false,
      category: 'text',
    },
  ];

  await supabase.from('templates').insert(defaultTemplates);
}

/**
 * Get template by ID
 */
export async function getTemplateById(id: string): Promise<PdfTemplate | null> {
  const { data, error } = await supabase
    .from('templates')
    .select('*')
    .eq('id', id)
    .single();

  if (error || !data) {
    return null;
  }

  return transformRowToPdfTemplate(data);
}

// =============================================================================
// Database Schema Helper (for reference)
// =============================================================================

/*
CREATE TABLE templates (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  template_json JSONB NOT NULL,
  user_id VARCHAR(255) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  is_public BOOLEAN DEFAULT FALSE,
  category VARCHAR(100),
  tags TEXT[]
);

CREATE INDEX idx_templates_user_id ON templates(user_id);
CREATE INDEX idx_templates_category ON templates(category);
CREATE INDEX idx_templates_is_public ON templates(is_public);
CREATE INDEX idx_templates_updated_at ON templates(updated_at DESC);
*/













// src/app/api/export-pdf/route.ts - CREATED: 2025-07-07 - PDF export API endpoint

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { JSONContent } from '@tiptap/core';
import { generate } from '@pdfme/generator';
import { TiptapToPdfmeAdapter } from '@/lib/adapters/tiptap-to-pdfme';
import { getTemplateById } from '@/app/api/templates/route';
import { 
  Template, 
  PdfGenerationError, 
  validateTemplate,
  createBasicTextTemplate 
} from '@/types/template';

// =============================================================================
// Request Schema
// =============================================================================

const ExportPdfRequestSchema = z.object({
  tiptapJson: z.any(), // JSONContent from Tiptap
  templateId: z.string().optional(),
  customTemplate: z.any().optional(), // Custom template JSON
  options: z.object({
    filename: z.string().default('document.pdf'),
    pageSize: z.enum(['A4', 'LETTER', 'A3']).default('A4'),
    margin: z.number().min(5).max(50).default(20),
    font: z.string().default('NotoSansCJK-Regular'),
    fontSize: z.number().min(8).max(24).default(12),
  }).optional(),
});

interface ExportPdfResponse {
  success: boolean;
  data?: {
    filename: string;
    size: number;
    pageCount: number;
    generationTime: number;
  };
  error?: string;
  details?: any;
}

// =============================================================================
// POST Handler - Export PDF
// =============================================================================

export async function POST(request: NextRequest): Promise<NextResponse> {
  const startTime = Date.now();

  try {
    // Parse and validate request body
    const body = await request.json().catch(() => null);
    
    if (!body) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid JSON in request body',
        },
        { status: 400 }
      );
    }

    const validationResult = ExportPdfRequestSchema.safeParse(body);
    
    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request format',
          details: validationResult.error.errors,
        },
        { status: 400 }
      );
    }

    const { tiptapJson, templateId, customTemplate, options } = validationResult.data;

    // Validate Tiptap JSON structure
    if (!tiptapJson || !tiptapJson.type || tiptapJson.type !== 'doc') {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid Tiptap JSON structure',
        },
        { status: 400 }
      );
    }

    // Get or create template
    let template: Template;
    
    if (customTemplate) {
      // Use custom template
      try {
        template = validateTemplate(customTemplate);
      } catch (error) {
        return NextResponse.json(
          {
            success: false,
            error: 'Invalid custom template',
            details: error instanceof Error ? error.message : 'Template validation failed',
          },
          { status: 400 }
        );
      }
    } else if (templateId) {
      // Get template from database
      const templateData = await getTemplateById(templateId);
      if (!templateData) {
        return NextResponse.json(
          {
            success: false,
            error: 'Template not found',
          },
          { status: 404 }
        );
      }
      template = templateData.template_json;
    } else {
      // Use default template
      template = createBasicTextTemplate({
        pageWidth: getPageDimensions(options?.pageSize || 'A4').width,
        pageHeight: getPageDimensions(options?.pageSize || 'A4').height,
        margin: options?.margin || 20,
        defaultFont: options?.font || 'NotoSansCJK-Regular',
        defaultFontSize: options?.fontSize || 12,
      });
    }

    // Transform Tiptap JSON to pdfme format
    let pdfmeDocument;
    try {
      const adapter = new TiptapToPdfmeAdapter({
        pageWidth: getPageDimensions(options?.pageSize || 'A4').width,
        pageHeight: getPageDimensions(options?.pageSize || 'A4').height,
        margin: options?.margin || 20,
        defaultFont: options?.font || 'NotoSansCJK-Regular',
        defaultFontSize: options?.fontSize || 12,
      });

      pdfmeDocument = adapter.transform(tiptapJson);
    } catch (error) {
      console.error('Tiptap to pdfme transformation failed:', error);
      return NextResponse.json(
        {
          success: false,
          error: 'Failed to transform document for PDF generation',
          details: error instanceof Error ? error.message : 'Transformation failed',
        },
        { status: 500 }
      );
    }

    // Generate PDF using pdfme
    let pdfBuffer: Uint8Array;
    try {
      // If we have content from Tiptap, use the generated template and inputs
      // Otherwise, use the provided template with empty inputs
      const finalTemplate = pdfmeDocument.template.schemas[0].length > 0 
        ? pdfmeDocument.template 
        : template;
      
      const finalInputs = pdfmeDocument.inputs.length > 0 && Object.keys(pdfmeDocument.inputs[0]).length > 0
        ? pdfmeDocument.inputs
        : [{}];

      pdfBuffer = await generate({
        template: finalTemplate,
        inputs: finalInputs,
      });
    } catch (error) {
      console.error('PDF generation failed:', error);
      return NextResponse.json(
        {
          success: false,
          error: 'Failed to generate PDF',
          details: error instanceof Error ? error.message : 'PDF generation failed',
        },
        { status: 500 }
      );
    }

    // Calculate metadata
    const generationTime = Date.now() - startTime;
    const pdfSize = pdfBuffer.byteLength;
    const pageCount = estimatePageCount(pdfSize);

    // Return PDF as response
    const filename = options?.filename || 'document.pdf';
    
    return new NextResponse(pdfBuffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Length': pdfSize.toString(),
        'Content-Disposition': `attachment; filename="${filename}"`,
        'X-Generation-Time': generationTime.toString(),
        'X-PDF-Size': pdfSize.toString(),
        'X-Page-Count': pageCount.toString(),
      },
    });

  } catch (error) {
    console.error('Unexpected error in export-pdf endpoint:', error);

    return NextResponse.json(
      {
        success: false,
        error: 'Internal server error',
        details: process.env.NODE_ENV === 'development' 
          ? (error instanceof Error ? error.message : 'Unknown error')
          : undefined,
      },
      { status: 500 }
    );
  }
}

// =============================================================================
// Alternative POST Handler - JSON Response (for frontend handling)
// =============================================================================

export async function generatePdfAsBase64(
  tiptapJson: JSONContent,
  templateId?: string,
  customTemplate?: Template,
  options?: any
): Promise<{ success: true; data: string } | { success: false; error: string }> {
  try {
    // Similar logic as above but return base64 string instead of binary response
    
    let template: Template;
    
    if (customTemplate) {
      template = validateTemplate(customTemplate);
    } else if (templateId) {
      const templateData = await getTemplateById(templateId);
      if (!templateData) {
        return { success: false, error: 'Template not found' };
      }
      template = templateData.template_json;
    } else {
      template = createBasicTextTemplate();
    }

    const adapter = new TiptapToPdfmeAdapter(options);
    const pdfmeDocument = adapter.transform(tiptapJson);

    const finalTemplate = pdfmeDocument.template.schemas[0].length > 0 
      ? pdfmeDocument.template 
      : template;
    
    const finalInputs = pdfmeDocument.inputs.length > 0 && Object.keys(pdfmeDocument.inputs[0]).length > 0
      ? pdfmeDocument.inputs
      : [{}];

    const pdfBuffer = await generate({
      template: finalTemplate,
      inputs: finalInputs,
    });

    // Convert to base64
    const base64 = Buffer.from(pdfBuffer).toString('base64');
    
    return { success: true, data: base64 };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'PDF generation failed' 
    };
  }
}

// =============================================================================
// GET Handler - Health Check
// =============================================================================

export async function GET(): Promise<NextResponse> {
  try {
    return NextResponse.json(
      {
        status: 'ok',
        endpoint: 'export-pdf',
        timestamp: new Date().toISOString(),
        version: '1.0.0',
        supportedFormats: ['pdf'],
        supportedPageSizes: ['A4', 'LETTER', 'A3'],
      },
      { status: 200 }
    );
  } catch (error) {
    return NextResponse.json(
      {
        status: 'error',
        error: 'Health check failed',
      },
      { status: 500 }
    );
  }
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Get page dimensions for different page sizes
 */
function getPageDimensions(pageSize: 'A4' | 'LETTER' | 'A3'): { width: number; height: number } {
  const dimensions = {
    A4: { width: 210, height: 297 },
    LETTER: { width: 216, height: 279 },
    A3: { width: 297, height: 420 },
  };
  
  return dimensions[pageSize];
}

/**
 * Estimate page count from PDF file size (rough estimate)
 */
function estimatePageCount(pdfSize: number): number {
  // Very rough estimate: ~50KB per page on average
  return Math.max(1, Math.round(pdfSize / 50000));
}

/**
 * Validate file size limits
 */
function validateFileSize(size: number): boolean {
  const MAX_SIZE = 10 * 1024 * 1024; // 10MB
  return size <= MAX_SIZE;
}

/**
 * Generate safe filename
 */
function generateSafeFilename(filename: string): string {
  return filename
    .replace(/[^a-zA-Z0-9.-]/g, '_')
    .replace(/_{2,}/g, '_')
    .replace(/^_|_$/g, '');
}

/**
 * Log PDF generation for monitoring
 */
function logPdfGeneration(
  size: number,
  pageCount: number,
  generationTime: number
): void {
  if (process.env.NODE_ENV === 'development') {
    console.log(`[PDF-EXPORT] Generated ${pageCount} pages, ${size} bytes in ${generationTime}ms`);
  }
}

// =============================================================================
// Error Response Helpers
// =============================================================================

export function createPdfErrorResponse(
  error: string,
  status: number = 400,
  details?: any
): NextResponse<ExportPdfResponse> {
  return NextResponse.json(
    {
      success: false,
      error,
      details,
    },
    { status }
  );
}

// =============================================================================
// Custom Error Classes
// =============================================================================

export class PdfExportError extends Error {
  constructor(message: string, public cause?: Error) {
    super(message);
    this.name = "PdfExportError";
  }
}

export class TemplateNotFoundError extends Error {
  constructor(templateId: string) {
    super(`Template with ID ${templateId} not found`);
    this.name = "TemplateNotFoundError";
  }
}











// src/hooks/useDocumentProcessing.ts - CREATED: 2025-07-07 - Document processing hook

import { useState, useCallback, useRef } from 'react';
import { JSONContent } from '@tiptap/core';
import { CanonicalDocument } from '@/types/document';
import { PdfTemplate } from '@/types/template';

// =============================================================================
// Hook State Interface
// =============================================================================

interface DocumentProcessingState {
  // Processing states
  isAnalyzing: boolean;
  isGeneratingPdf: boolean;
  isLoadingTemplates: boolean;
  
  // Document data
  rawText: string;
  canonicalDocument: CanonicalDocument | null;
  tiptapContent: JSONContent | null;
  
  // Templates
  templates: PdfTemplate[];
  selectedTemplate: PdfTemplate | null;
  
  // Metadata
  processingMetadata: {
    processingTime?: number;
    textLength?: number;
    blockCount?: number;
    confidenceScore?: number;
  } | null;
  
  // Error handling
  error: string | null;
  lastOperation: string | null;
}

interface DocumentProcessingActions {
  // Text processing
  setRawText: (text: string) => void;
  processText: (text?: string, options?: ProcessingOptions) => Promise<void>;
  clearDocument: () => void;
  
  // Template management
  loadTemplates: () => Promise<void>;
  selectTemplate: (template: PdfTemplate | null) => void;
  
  // PDF generation
  generatePdf: (options?: PdfGenerationOptions) => Promise<void>;
  downloadPdf: (filename?: string) => Promise<void>;
  
  // Content management
  updateTiptapContent: (content: JSONContent) => void;
  
  // Error handling
  clearError: () => void;
  retryLastOperation: () => Promise<void>;
}

interface ProcessingOptions {
  language?: string;
  documentType?: 'report' | 'article' | 'form' | 'contract' | 'other';
  enableFallback?: boolean;
}

interface PdfGenerationOptions {
  templateId?: string;
  filename?: string;
  pageSize?: 'A4' | 'LETTER' | 'A3';
  margin?: number;
  font?: string;
  fontSize?: number;
}

// =============================================================================
// Main Hook
// =============================================================================

export const useDocumentProcessing = (): DocumentProcessingState & DocumentProcessingActions => {
  // State management
  const [state, setState] = useState<DocumentProcessingState>({
    isAnalyzing: false,
    isGeneratingPdf: false,
    isLoadingTemplates: false,
    rawText: '',
    canonicalDocument: null,
    tiptapContent: null,
    templates: [],
    selectedTemplate: null,
    processingMetadata: null,
    error: null,
    lastOperation: null,
  });

  // Refs for retry functionality
  const lastOperationRef = useRef<{
    operation: string;
    args: any[];
  } | null>(null);

  // =============================================================================
  // Text Processing Actions
  // =============================================================================

  const setRawText = useCallback((text: string) => {
    setState(prev => ({
      ...prev,
      rawText: text,
      error: null,
    }));
  }, []);

  const processText = useCallback(async (text?: string, options?: ProcessingOptions) => {
    const textToProcess = text || state.rawText;
    
    if (!textToProcess.trim()) {
      setState(prev => ({
        ...prev,
        error: 'Please enter some text to process',
      }));
      return;
    }

    // Store operation for retry
    lastOperationRef.current = {
      operation: 'processText',
      args: [textToProcess, options],
    };

    setState(prev => ({
      ...prev,
      isAnalyzing: true,
      error: null,
      lastOperation: 'processText',
    }));

    try {
      const response = await fetch('/api/analyze', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          text: textToProcess,
          options: options || {},
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Analysis failed');
      }

      setState(prev => ({
        ...prev,
        canonicalDocument: result.data.canonical,
        tiptapContent: result.data.tiptap,
        processingMetadata: result.data.metadata,
        rawText: textToProcess,
        isAnalyzing: false,
        error: null,
      }));

    } catch (error) {
      console.error('Document processing failed:', error);
      setState(prev => ({
        ...prev,
        isAnalyzing: false,
        error: error instanceof Error ? error.message : 'Failed to process document',
      }));
    }
  }, [state.rawText]);

  const clearDocument = useCallback(() => {
    setState(prev => ({
      ...prev,
      rawText: '',
      canonicalDocument: null,
      tiptapContent: null,
      processingMetadata: null,
      error: null,
      lastOperation: null,
    }));
    lastOperationRef.current = null;
  }, []);

  // =============================================================================
  // Template Management Actions
  // =============================================================================

  const loadTemplates = useCallback(async () => {
    setState(prev => ({
      ...prev,
      isLoadingTemplates: true,
      error: null,
      lastOperation: 'loadTemplates',
    }));

    // Store operation for retry
    lastOperationRef.current = {
      operation: 'loadTemplates',
      args: [],
    };

    try {
      const response = await fetch('/api/templates');

      if (!response.ok) {
        throw new Error(`Failed to load templates: ${response.statusText}`);
      }

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Failed to load templates');
      }

      setState(prev => ({
        ...prev,
        templates: result.data || [],
        isLoadingTemplates: false,
        error: null,
      }));

    } catch (error) {
      console.error('Template loading failed:', error);
      setState(prev => ({
        ...prev,
        isLoadingTemplates: false,
        error: error instanceof Error ? error.message : 'Failed to load templates',
      }));
    }
  }, []);

  const selectTemplate = useCallback((template: PdfTemplate | null) => {
    setState(prev => ({
      ...prev,
      selectedTemplate: template,
      error: null,
    }));
  }, []);

  // =============================================================================
  // PDF Generation Actions
  // =============================================================================

  const generatePdf = useCallback(async (options?: PdfGenerationOptions) => {
    if (!state.tiptapContent) {
      setState(prev => ({
        ...prev,
        error: 'No document content to export. Please process some text first.',
      }));
      return;
    }

    // Store operation for retry
    lastOperationRef.current = {
      operation: 'generatePdf',
      args: [options],
    };

    setState(prev => ({
      ...prev,
      isGeneratingPdf: true,
      error: null,
      lastOperation: 'generatePdf',
    }));

    try {
      const requestBody = {
        tiptapJson: state.tiptapContent,
        templateId: options?.templateId || state.selectedTemplate?.id,
        options: {
          filename: options?.filename || 'document.pdf',
          pageSize: options?.pageSize || 'A4',
          margin: options?.margin || 20,
          font: options?.font || 'NotoSansCJK-Regular',
          fontSize: options?.fontSize || 12,
        },
      };

      const response = await fetch('/api/export-pdf', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `PDF generation failed: ${response.statusText}`);
      }

      // Get PDF blob
      const pdfBlob = await response.blob();
      
      // Create download link
      const url = URL.createObjectURL(pdfBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = options?.filename || 'document.pdf';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      setState(prev => ({
        ...prev,
        isGeneratingPdf: false,
        error: null,
      }));

    } catch (error) {
      console.error('PDF generation failed:', error);
      setState(prev => ({
        ...prev,
        isGeneratingPdf: false,
        error: error instanceof Error ? error.message : 'Failed to generate PDF',
      }));
    }
  }, [state.tiptapContent, state.selectedTemplate]);

  const downloadPdf = useCallback(async (filename?: string) => {
    await generatePdf({ filename });
  }, [generatePdf]);

  // =============================================================================
  // Content Management Actions
  // =============================================================================

  const updateTiptapContent = useCallback((content: JSONContent) => {
    setState(prev => ({
      ...prev,
      tiptapContent: content,
      error: null,
    }));
  }, []);

  // =============================================================================
  // Error Handling Actions
  // =============================================================================

  const clearError = useCallback(() => {
    setState(prev => ({
      ...prev,
      error: null,
    }));
  }, []);

  const retryLastOperation = useCallback(async () => {
    if (!lastOperationRef.current) {
      setState(prev => ({
        ...prev,
        error: 'No operation to retry',
      }));
      return;
    }

    const { operation, args } = lastOperationRef.current;

    switch (operation) {
      case 'processText':
        await processText(...args);
        break;
      case 'loadTemplates':
        await loadTemplates();
        break;
      case 'generatePdf':
        await generatePdf(...args);
        break;
      default:
        setState(prev => ({
          ...prev,
          error: 'Unknown operation to retry',
        }));
    }
  }, [processText, loadTemplates, generatePdf]);

  // =============================================================================
  // Return Hook Interface
  // =============================================================================

  return {
    // State
    ...state,
    
    // Actions
    setRawText,
    processText,
    clearDocument,
    loadTemplates,
    selectTemplate,
    generatePdf,
    downloadPdf,
    updateTiptapContent,
    clearError,
    retryLastOperation,
  };
};

// =============================================================================
// Utility Hooks
// =============================================================================

/**
 * Hook for managing processing progress
 */
export const useProcessingProgress = () => {
  const [progress, setProgress] = useState(0);
  const [status, setStatus] = useState<'idle' | 'processing' | 'complete' | 'error'>('idle');

  const startProgress = useCallback(() => {
    setStatus('processing');
    setProgress(0);
    
    // Simulate progress
    const interval = setInterval(() => {
      setProgress(prev => {
        if (prev >= 90) {
          clearInterval(interval);
          return prev;
        }
        return prev + Math.random() * 10;
      });
    }, 200);

    return () => clearInterval(interval);
  }, []);

  const completeProgress = useCallback(() => {
    setProgress(100);
    setStatus('complete');
  }, []);

  const errorProgress = useCallback(() => {
    setStatus('error');
  }, []);

  const resetProgress = useCallback(() => {
    setProgress(0);
    setStatus('idle');
  }, []);

  return {
    progress,
    status,
    startProgress,
    completeProgress,
    errorProgress,
    resetProgress,
  };
};

/**
 * Hook for debounced text processing
 */
export const useDebouncedProcessing = (delay: number = 1000) => {
  const [debouncedText, setDebouncedText] = useState('');
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  const updateText = useCallback((text: string) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    timeoutRef.current = setTimeout(() => {
      setDebouncedText(text);
    }, delay);
  }, [delay]);

  return {
    debouncedText,
    updateText,
  };
};











// src/app/rebrand/page.tsx - CREATED: 2025-07-07 - Main document processing interface

"use client";

import React, { useState, useEffect } from 'react';
import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Table from '@tiptap/extension-table';
import TableRow from '@tiptap/extension-table-row';
import TableHeader from '@tiptap/extension-table-header';
import TableCell from '@tiptap/extension-table-cell';
import Image from '@tiptap/extension-image';
import Link from '@tiptap/extension-link';

import { useDocumentProcessing } from '@/hooks/useDocumentProcessing';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Switch } from '@/components/ui/switch';
import { 
  Dialog, 
  DialogContent, 
  DialogDescription, 
  DialogHeader, 
  DialogTitle, 
  DialogTrigger 
} from '@/components/ui/dialog';

import { 
  FileText, 
  Zap, 
  Download, 
  Settings, 
  RefreshCw, 
  AlertCircle, 
  CheckCircle2,
  Upload,
  Eye,
  Loader2
} from 'lucide-react';

// =============================================================================
// Main Component
// =============================================================================

export default function RebrandPage() {
  const {
    // State
    isAnalyzing,
    isGeneratingPdf,
    isLoadingTemplates,
    rawText,
    canonicalDocument,
    tiptapContent,
    templates,
    selectedTemplate,
    processingMetadata,
    error,
    lastOperation,
    
    // Actions
    setRawText,
    processText,
    clearDocument,
    loadTemplates,
    selectTemplate,
    generatePdf,
    updateTiptapContent,
    clearError,
    retryLastOperation,
  } = useDocumentProcessing();

  // Local state for UI
  const [activeTab, setActiveTab] = useState<'input' | 'editor' | 'preview'>('input');
  const [processingOptions, setProcessingOptions] = useState({
    language: 'en',
    documentType: 'other' as const,
    enableFallback: true,
  });
  const [pdfOptions, setPdfOptions] = useState({
    filename: 'document.pdf',
    pageSize: 'A4' as const,
    margin: 20,
    font: 'NotoSansCJK-Regular',
    fontSize: 12,
  });

  // Tiptap editor setup
  const editor = useEditor({
    extensions: [
      StarterKit,
      Table.configure({
        resizable: true,
      }),
      TableRow,
      TableHeader,
      TableCell,
      Image,
      Link.configure({
        openOnClick: false,
      }),
    ],
    content: tiptapContent,
    onUpdate: ({ editor }) => {
      const json = editor.getJSON();
      updateTiptapContent(json);
    },
    editable: !!tiptapContent,
  });

  // Effects
  useEffect(() => {
    loadTemplates();
  }, [loadTemplates]);

  useEffect(() => {
    if (editor && tiptapContent) {
      editor.commands.setContent(tiptapContent);
      if (activeTab === 'input') {
        setActiveTab('editor');
      }
    }
  }, [editor, tiptapContent, activeTab]);

  // =============================================================================
  // Event Handlers
  // =============================================================================

  const handleProcessText = async () => {
    if (!rawText.trim()) return;
    await processText(rawText, processingOptions);
  };

  const handleGeneratePdf = async () => {
    await generatePdf({
      templateId: selectedTemplate?.id,
      ...pdfOptions,
    });
  };

  const handleClearAll = () => {
    clearDocument();
    setActiveTab('input');
    if (editor) {
      editor.commands.clearContent();
    }
  };

  // =============================================================================
  // Render Functions
  // =============================================================================

  const renderProcessingProgress = () => {
    if (!isAnalyzing && !isGeneratingPdf) return null;

    return (
      <Card className="mb-6">
        <CardContent className="pt-6">
          <div className="flex items-center space-x-4">
            <Loader2 className="h-4 w-4 animate-spin" />
            <div className="flex-1">
              <p className="text-sm font-medium">
                {isAnalyzing && 'Analyzing document with AI...'}
                {isGeneratingPdf && 'Generating PDF...'}
              </p>
              <Progress value={45} className="mt-2" />
            </div>
          </div>
        </CardContent>
      </Card>
    );
  };

  const renderError = () => {
    if (!error) return null;

    return (
      <Card className="mb-6 border-destructive">
        <CardContent className="pt-6">
          <div className="flex items-start space-x-4">
            <AlertCircle className="h-5 w-5 text-destructive mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-destructive">Error</p>
              <p className="text-sm text-muted-foreground mt-1">{error}</p>
              <div className="flex space-x-2 mt-3">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={retryLastOperation}
                  disabled={!lastOperation}
                >
                  <RefreshCw className="h-4 w-4 mr-2" />
                  Retry
                </Button>
                <Button size="sm" variant="ghost" onClick={clearError}>
                  Dismiss
                </Button>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  };

  const renderMetadata = () => {
    if (!processingMetadata) return null;

    return (
      <Card className="mb-6">
        <CardHeader>
          <CardTitle className="text-sm">Processing Information</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
            <div>
              <p className="text-muted-foreground">Processing Time</p>
              <p className="font-medium">{processingMetadata.processingTime}ms</p>
            </div>
            <div>
              <p className="text-muted-foreground">Text Length</p>
              <p className="font-medium">{processingMetadata.textLength} chars</p>
            </div>
            <div>
              <p className="text-muted-foreground">Blocks Found</p>
              <p className="font-medium">{processingMetadata.blockCount}</p>
            </div>
            <div>
              <p className="text-muted-foreground">Confidence</p>
              <Badge variant={processingMetadata.confidenceScore > 0.8 ? 'default' : 'secondary'}>
                {Math.round((processingMetadata.confidenceScore || 0) * 100)}%
              </Badge>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  };

  const renderInputTab = () => (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Upload className="h-5 w-5" />
            Input Your Text
          </CardTitle>
          <CardDescription>
            Paste your raw text here. Our AI will analyze and structure it automatically.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <Textarea
            placeholder="Paste your document text here..."
            value={rawText}
            onChange={(e) => setRawText(e.target.value)}
            rows={12}
            className="min-h-[300px]"
          />
          
          <div className="flex flex-col sm:flex-row gap-4">
            <div className="flex-1">
              <Label htmlFor="document-type">Document Type</Label>
              <Select
                value={processingOptions.documentType}
                onValueChange={(value: any) => 
                  setProcessingOptions(prev => ({ ...prev, documentType: value }))
                }
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="report">Report</SelectItem>
                  <SelectItem value="article">Article</SelectItem>
                  <SelectItem value="form">Form</SelectItem>
                  <SelectItem value="contract">Contract</SelectItem>
                  <SelectItem value="other">Other</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="flex-1">
              <Label htmlFor="language">Language</Label>
              <Select
                value={processingOptions.language}
                onValueChange={(value) => 
                  setProcessingOptions(prev => ({ ...prev, language: value }))
                }
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="en">English</SelectItem>
                  <SelectItem value="vi">Vietnamese</SelectItem>
                  <SelectItem value="fr">French</SelectItem>
                  <SelectItem value="de">German</SelectItem>
                  <SelectItem value="es">Spanish</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>

          <div className="flex items-center space-x-2">
            <Switch
              id="enable-fallback"
              checked={processingOptions.enableFallback}
              onCheckedChange={(checked) =>
                setProcessingOptions(prev => ({ ...prev, enableFallback: checked }))
              }
            />
            <Label htmlFor="enable-fallback">Enable fallback processing</Label>
          </div>

          <div className="flex space-x-2">
            <Button
              onClick={handleProcessText}
              disabled={!rawText.trim() || isAnalyzing}
              className="flex-1"
            >
              {isAnalyzing ? (
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              ) : (
                <Zap className="h-4 w-4 mr-2" />
              )}
              Process Text with AI
            </Button>
            
            {(canonicalDocument || tiptapContent) && (
              <Button variant="outline" onClick={handleClearAll}>
                Clear All
              </Button>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );

  const renderEditorTab = () => {
    if (!editor || !tiptapContent) {
      return (
        <Card>
          <CardContent className="pt-6">
            <div className="text-center py-8">
              <FileText className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
              <p className="text-muted-foreground">
                Process some text first to access the editor
              </p>
            </div>
          </CardContent>
        </Card>
      );
    }

    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <FileText className="h-5 w-5" />
            Rich Text Editor
          </CardTitle>
          <CardDescription>
            Edit your structured document. Changes are automatically saved.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="border rounded-lg">
            {/* Editor Toolbar */}
            <div className="border-b p-3 flex flex-wrap gap-2">
              <Button
                size="sm"
                variant={editor.isActive('bold') ? 'default' : 'outline'}
                onClick={() => editor.chain().focus().toggleBold().run()}
              >
                <strong>B</strong>
              </Button>
              <Button
                size="sm"
                variant={editor.isActive('italic') ? 'default' : 'outline'}
                onClick={() => editor.chain().focus().toggleItalic().run()}
              >
                <em>I</em>
              </Button>
              <Button
                size="sm"
                variant={editor.isActive('heading', { level: 1 }) ? 'default' : 'outline'}
                onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
              >
                H1
              </Button>
              <Button
                size="sm"
                variant={editor.isActive('heading', { level: 2 }) ? 'default' : 'outline'}
                onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
              >
                H2
              </Button>
              <Button
                size="sm"
                variant={editor.isActive('bulletList') ? 'default' : 'outline'}
                onClick={() => editor.chain().focus().toggleBulletList().run()}
              >
                â€¢List
              </Button>
              <Button
                size="sm"
                variant={editor.isActive('orderedList') ? 'default' : 'outline'}
                onClick={() => editor.chain().focus().toggleOrderedList().run()}
              >
                1.List
              </Button>
            </div>
            
            {/* Editor Content */}
            <div className="p-4 min-h-[400px]">
              <EditorContent editor={editor} />
            </div>
          </div>
        </CardContent>
      </Card>
    );
  };

  const renderPreviewTab = () => (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Eye className="h-5 w-5" />
            PDF Export Settings
          </CardTitle>
          <CardDescription>
            Configure your PDF output settings and download options.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <Label htmlFor="filename">Filename</Label>
              <Input
                id="filename"
                value={pdfOptions.filename}
                onChange={(e) => setPdfOptions(prev => ({ ...prev, filename: e.target.value }))}
              />
            </div>
            
            <div>
              <Label htmlFor="page-size">Page Size</Label>
              <Select
                value={pdfOptions.pageSize}
                onValueChange={(value: any) => 
                  setPdfOptions(prev => ({ ...prev, pageSize: value }))
                }
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="A4">A4</SelectItem>
                  <SelectItem value="LETTER">Letter</SelectItem>
                  <SelectItem value="A3">A3</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div>
              <Label htmlFor="margin">Margin (mm)</Label>
              <Input
                id="margin"
                type="number"
                min="5"
                max="50"
                value={pdfOptions.margin}
                onChange={(e) => setPdfOptions(prev => ({ ...prev, margin: parseInt(e.target.value) }))}
              />
            </div>
            
            <div>
              <Label htmlFor="font-size">Font Size</Label>
              <Input
                id="font-size"
                type="number"
                min="8"
                max="24"
                value={pdfOptions.fontSize}
                onChange={(e) => setPdfOptions(prev => ({ ...prev, fontSize: parseInt(e.target.value) }))}
              />
            </div>
          </div>

          {templates.length > 0 && (
            <div>
              <Label htmlFor="template">PDF Template (Optional)</Label>
              <Select
                value={selectedTemplate?.id || 'none'}
                onValueChange={(value) => {
                  const template = value === 'none' ? null : templates.find(t => t.id === value);
                  selectTemplate(template || null);
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select a template" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="none">Default Template</SelectItem>
                  {templates.map((template) => (
                    <SelectItem key={template.id} value={template.id}>
                      {template.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          )}

          <Button
            onClick={handleGeneratePdf}
            disabled={!tiptapContent || isGeneratingPdf}
            className="w-full"
            size="lg"
          >
            {isGeneratingPdf ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <Download className="h-4 w-4 mr-2" />
            )}
            Generate & Download PDF
          </Button>
        </CardContent>
      </Card>

      {canonicalDocument && (
        <Card>
          <CardHeader>
            <CardTitle className="text-sm">Document Structure Preview</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-xs bg-muted rounded p-4 overflow-auto max-h-60">
              <pre>{JSON.stringify(canonicalDocument, null, 2)}</pre>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );

  // =============================================================================
  // Main Render
  // =============================================================================

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-900 dark:to-slate-800">
      <div className="container mx-auto px-4 py-8">
        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-4xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-2">
            Document Rebrander
          </h1>
          <p className="text-muted-foreground">
            Transform raw text into beautiful, structured documents with AI
          </p>
        </div>

        {/* Progress and Error Messages */}
        {renderProcessingProgress()}
        {renderError()}
        {renderMetadata()}

        {/* Main Interface */}
        <Tabs value={activeTab} onValueChange={(value: any) => setActiveTab(value)}>
          <TabsList className="grid w-full grid-cols-3">
            <TabsTrigger value="input" className="flex items-center gap-2">
              <Upload className="h-4 w-4" />
              Input Text
            </TabsTrigger>
            <TabsTrigger 
              value="editor" 
              className="flex items-center gap-2"
              disabled={!tiptapContent}
            >
              <FileText className="h-4 w-4" />
              Edit Document
            </TabsTrigger>
            <TabsTrigger 
              value="preview" 
              className="flex items-center gap-2"
              disabled={!tiptapContent}
            >
              <Download className="h-4 w-4" />
              Export PDF
            </TabsTrigger>
          </TabsList>

          <TabsContent value="input">{renderInputTab()}</TabsContent>
          <TabsContent value="editor">{renderEditorTab()}</TabsContent>
          <TabsContent value="preview">{renderPreviewTab()}</TabsContent>
        </Tabs>
      </div>
    </div>
  );
}






